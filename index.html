<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DJ-ViBES: AI Mix Creator</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ’¿</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* --- NEW: Light and Dark Theme Variables --- */
        :root {
            --y2k-blue: #3a86ff;
            --y2k-pink: #ff006e;
            --y2k-purple: #8338ec;
            --danger-red: #e63946;
            --danger-red-hover: #d62828;

            /* Light Theme Colors */
            --bg-color: #DCE1E9;
            --shell-bg: #BFC8D9;
            --shell-highlight: #E1E8F2;
            --shell-shadow: #A8B2C2;
            --screen-bg: #C5D4E8;
            --screen-glow: rgba(58, 134, 255, 0.3);
            --text-primary: #212536;
            --text-secondary: #F0F4FA;
            --translucent-bg: rgba(58, 134, 255, 0.8);
            --translucent-bg-hover: rgba(58, 134, 255, 1);
            --translucent-dark-bg: rgba(33, 37, 54, 0.7);
            --translucent-dark-bg-hover: rgba(33, 37, 54, 0.9);
            --border-color: #ADB8CC;
            --header-border: var(--shell-shadow);
            --button-shadow: 3px 3px 6px var(--shell-shadow), -3px -3px 6px var(--shell-highlight);
            --button-shadow-active: inset 3px 3px 6px var(--shell-shadow), inset -3px -3px 6px var(--shell-highlight);
        }

        body.dark-mode {
            /* Dark Theme Colors */
            --bg-color: #1a1c23;
            --shell-bg: #212536;
            --shell-highlight: #2c3142;
            --shell-shadow: #111318;
            --screen-bg: #1c202b;
            --screen-glow: rgba(255, 0, 110, 0.3);
            --text-primary: #F0F4FA;
            --text-secondary: #212536;
            --translucent-bg: rgba(255, 0, 110, 0.8);
            --translucent-bg-hover: rgba(255, 0, 110, 1);
            --translucent-dark-bg: rgba(240, 244, 250, 0.1);
            --translucent-dark-bg-hover: rgba(240, 244, 250, 0.2);
            --border-color: #2c3142;
            --header-border: var(--shell-highlight);
            --button-shadow: 3px 3px 6px var(--shell-shadow), -3px -3px 6px var(--shell-highlight);
            --button-shadow-active: inset 3px 3px 6px var(--shell-shadow), inset -3px -3px 6px var(--shell-highlight);
        }

        body {
            font-family: 'Roboto Mono', monospace;
            background-color: var(--bg-color);
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Hardware Shell Styling */
        #app-container {
            width: 100%;
            max-width: 40rem;
            background: linear-gradient(145deg, var(--shell-highlight), var(--shell-bg));
            border-radius: 2rem;
            box-shadow: 
                -10px -10px 20px var(--shell-highlight), 
                10px 10px 20px var(--shell-shadow);
            padding: 1.5rem;
            border: 3px solid var(--border-color);
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        #screen-area {
            background-color: var(--screen-bg);
            border: 2px solid var(--shell-shadow);
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: inset 5px 5px 10px var(--shell-shadow), inset -5px -5px 10px var(--shell-highlight);
            margin-bottom: 1.5rem;
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        h1 {
            font-family: 'VT323', monospace;
            font-size: 3rem;
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 0.5rem;
            letter-spacing: 2px;
            text-shadow: 1px 1px 0px var(--shell-highlight);
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }

        /* Login View */
        #login-view p {
            color: var(--text-primary);
            margin-bottom: 2rem;
            text-align: center;
            font-size: 0.9rem;
        }

        #login-button {
            display: block;
            width: fit-content;
            margin: 0 auto;
            background: var(--translucent-bg);
            color: var(--text-secondary);
            font-weight: 700;
            padding: 0.75rem 2rem;
            border-radius: 0.5rem;
            font-size: 1.125rem;
            transition: all 0.2s ease-in-out;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                inset 1px 1px 2px rgba(255, 255, 255, 0.4),
                3px 3px 6px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        #login-button:hover {
            background-color: var(--translucent-bg-hover);
            transform: translateY(-2px);
            box-shadow: 
                inset 1px 1px 2px rgba(255, 255, 255, 0.4),
                5px 5px 10px rgba(0, 0, 0, 0.3);
        }

        /* Main View */
        #main-view {
            display: none;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px dashed var(--header-border);
            transition: border-color 0.3s ease;
        }

        #main-view h1 {
            font-size: 1.75rem;
            text-align: left;
            margin: 0;
        }

        /* --- NEW: Theme Toggle Button --- */
        #theme-toggle {
            background: var(--shell-bg);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--button-shadow);
            transition: all 0.2s ease-in-out;
            color: var(--text-primary);
            margin-left: 1rem;
        }

        #theme-toggle:active {
            box-shadow: var(--button-shadow-active);
            transform: translateY(1px);
        }

        #theme-toggle .sun-icon, #theme-toggle .moon-icon {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .sun-icon { display: none; }
        .moon-icon { display: block; }
        body.dark-mode .sun-icon { display: block; }
        body.dark-mode .moon-icon { display: none; }


        #user-profile {
            display: flex;
            align-items: center;
            background: var(--shell-bg);
            padding: 0.25rem 0.5rem;
            border-radius: 0.5rem;
            box-shadow: inset 2px 2px 4px var(--shell-shadow), inset -2px -2px 4px var(--shell-highlight);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        #user-profile span {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-primary);
            margin-right: 0.75rem;
            transition: color 0.3s ease;
        }

        #user-profile img {
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            border: 2px solid var(--shell-highlight);
            transition: border-color 0.3s ease;
        }

        .form-section {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            font-family: 'VT323', monospace;
            letter-spacing: 1px;
            text-align: center;
            transition: color 0.3s ease;
        }
        
        .label-desc {
            font-size: 0.8rem;
            color: var(--text-primary);
            opacity: 0.8;
            margin-bottom: 0.75rem;
            transition: color 0.3s ease;
        }

        textarea {
            width: 100%;
            padding: 1rem;
            background-color: var(--translucent-dark-bg);
            border: 2px solid var(--shell-shadow);
            border-radius: 0.5rem;
            color: var(--text-primary);
            transition: all 0.2s;
            box-sizing: border-box;
            font-family: 'Roboto Mono', monospace;
            box-shadow: inset 3px 3px 5px rgba(0,0,0,0.3);
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            box-shadow: inset 3px 3px 5px rgba(0,0,0,0.3), 0 0 15px var(--screen-glow);
            border-color: var(--y2k-blue);
        }
        
        .controls-grid {
            margin-bottom: 2rem;
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            align-items: center;
        }

        @media (min-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .d-pad-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .d-pad-input {
            background: var(--shell-bg);
            box-shadow: inset 2px 2px 4px var(--shell-shadow), inset -2px -2px 4px var(--shell-highlight);
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            text-align: center;
            width: 70px;
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            color: var(--text-primary);
            border: 1px solid var(--shell-shadow);
            transition: all 0.3s ease;
        }
        .d-pad-input:focus {
            outline: none;
            box-shadow: inset 2px 2px 4px var(--shell-shadow), 
                        inset -2px -2px 4px var(--shell-highlight),
                        0 0 10px var(--screen-glow);
            border-color: var(--y2k-blue);
        }

        .d-pad-input::-webkit-outer-spin-button,
        .d-pad-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .d-pad-input[type=number] {
            -moz-appearance: textfield;
        }

        .d-pad-button {
            background: var(--shell-bg);
            color: var(--text-primary);
            border: none;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 1.5rem;
            font-weight: bold;
            transition: all 0.1s ease-in;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .d-pad-button:active {
            box-shadow: var(--button-shadow-active);
            transform: translateY(1px);
        }

        #generate-button {
            width: 100%;
            background: var(--y2k-pink);
            color: var(--text-secondary);
            font-weight: 700;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            font-size: 1.25rem;
            font-family: 'VT323', monospace;
            letter-spacing: 2px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.4);
            cursor: pointer;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
            box-shadow: 
                inset 1px 1px 2px rgba(255, 255, 255, 0.5),
                5px 5px 10px rgba(0, 0, 0, 0.2);
        }
        #generate-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 
                inset 1px 1px 2px rgba(255, 255, 255, 0.5),
                8px 8px 15px rgba(0, 0, 0, 0.3);
        }
        #generate-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #888;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.3);
        }
        #generate-button svg {
            margin-right: 0.75rem;
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.4));
        }

        #api-key-status {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-primary);
            opacity: 0.7;
            margin-top: 0.5rem;
            transition: color 0.3s ease;
        }

        /* Results View */
        #results-view {
            margin-top: 2rem;
            display: none;
        }

        #results-view h2 {
            font-family: 'VT323', monospace;
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 1rem;
            text-align: center;
        }

        #playlist-links {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        #playlist-links a {
            display: block;
            background-color: var(--translucent-dark-bg);
            padding: 1rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            text-decoration: none;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4);
            border: 1px solid rgba(0,0,0,0.2);
        }
        
        #playlist-links a:hover {
            background-color: var(--translucent-dark-bg-hover);
            transform: scale(1.02);
        }
        
        #playlist-links .playlist-name {
            font-weight: 600;
            color: var(--text-primary);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
        }
        
        #playlist-links .playlist-url {
            font-size: 0.875rem;
            color: var(--y2k-blue);
            text-decoration: underline;
        }

        /* Loading Modal */
        #loading-modal {
            display: none;
            position: fixed;
            inset: 0;
            background-color: rgba(30, 40, 60, 0.5);
            backdrop-filter: blur(5px);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 1rem;
        }
        
        #loading-modal .modal-content {
            background: linear-gradient(145deg, var(--shell-highlight), var(--shell-bg));
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 10px 10px 20px rgba(0,0,0,0.3);
            border: 2px solid var(--shell-shadow);
            width: 100%;
            max-width: 28rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--y2k-pink);
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
            margin-left: auto;
            margin-right: auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loading-text {
            color: var(--text-primary);
            font-size: 1.125rem;
            margin-bottom: 1rem;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .progress-container {
            width: 100%;
            background-color: var(--shell-shadow);
            border-radius: 9999px;
            height: 1rem;
            margin-bottom: 1rem;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.3);
            padding: 2px;
            transition: background-color 0.3s ease;
        }
        
        #progress-bar {
            background: var(--y2k-pink);
            height: 100%;
            border-radius: 9999px;
            transition: width 0.3s ease-in-out;
            width: 0%;
        }

        #cancel-button {
            margin-top: 1rem;
            background-color: var(--danger-red);
            color: var(--text-secondary);
            font-weight: 700;
            padding: 0.5rem 1.5rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            border: 2px solid rgba(255,255,255,0.3);
            cursor: pointer;
            box-shadow: 3px 3px 6px rgba(0,0,0,0.2);
        }
        #cancel-button:hover {
            background-color: var(--danger-red-hover);
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <!-- NEW: Script to apply theme on initial load to prevent flash -->
    <script>
        (function() {
            const theme = localStorage.getItem('theme');
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
            }
        })();
    </script>

    <div id="app-container">
        <div id="screen-area">
            <div id="login-view">
                <h1>DJ-ViBES</h1>
                <p>AI-powered mix generation unit. Please authenticate with Spotify to begin.</p>
                <button id="login-button">
                    Connect Spotify
                </button>
            </div>

            <div id="main-view">
                <div class="header">
                    <h1>DJ-ViBES</h1>
                    <div style="display: flex; align-items: center;">
                        <div id="user-profile"></div>
                        <!-- NEW: Theme toggle button HTML -->
                        <button id="theme-toggle" title="Toggle theme">
                            <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
                            <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                        </button>
                    </div>
                </div>

                <div class="form-section">
                    <label for="song-input">INPUT SEED DATA:</label>
                    <p class="label-desc">Enter songs, artists, or vibes. Be as specific or abstract as you like.</p>
                    <textarea id="song-input" rows="8" placeholder="> Brazillian 60s Fuzz Guitar&#10;> The Third Ear Band&#10;> https://open.spotify.com/track/0oP2XkRvW12u8gCxpBfVVU?si=...&#10;> A vibe like the closing credits of a film..."></textarea>
                </div>

                <div id="results-view">
                    <h2>MIXES GENERATED:</h2>
                    <div id="playlist-links"></div>
                </div>
            </div>
        </div>

        <!-- Controls outside the screen -->
        <div id="main-controls" style="display: none;">
             <div class="controls-grid">
                <div>
                    <label for="playlist-length">TRACKS / MIX</label>
                    <div class="d-pad-container">
                        <button type="button" class="d-pad-button" data-action="decrement" data-target="playlist-length">âˆ’</button>
                        <input type="number" id="playlist-length" class="d-pad-input" value="15" min="3" max="150">
                        <button type="button" class="d-pad-button" data-action="increment" data-target="playlist-length">+</button>
                    </div>
                </div>
                <div>
                    <label for="num-playlists">NUMBER OF MIXES</label>
                     <div class="d-pad-container">
                        <button type="button" class="d-pad-button" data-action="decrement" data-target="num-playlists">âˆ’</button>
                        <input type="number" id="num-playlists" class="d-pad-input" value="3" min="1" max="10">
                        <button type="button" class="d-pad-button" data-action="increment" data-target="num-playlists">+</button>
                    </div>
                </div>
            </div>

            <button id="generate-button" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 10v4"/><path d="M6 7v10"/><path d="M10 4v16"/><path d="M14 7v10"/><path d="M18 10v4"/><path d="M22 10v4"/></svg>
                <span id="generate-button-text">GENERATE MIXES</span>
            </button>
            <p id="api-key-status">SYSTEM BOOTING...</p>
        </div>


        <div id="loading-modal">
            <div class="modal-content">
                <div class="spinner"></div>
                <p id="loading-text">Crafting your mixes...</p>
                <div class="progress-container">
                    <div id="progress-bar"></div>
                </div>
                <button id="cancel-button">
                    Cancel
                </button>
            </div>
        </div>

    </div>

<script type="module">
        // --- All original JavaScript is unchanged ---
        // --- It has been kept here for full functionality ---
        // --- NEW theme toggle logic is added below ---

        const SPOTIFY_CLIENT_ID = "892656124cd5490c86e5eb1c1fd47cea"; 
        const REDIRECT_URI = window.location.origin + window.location.pathname;
        const FIREBASE_CONFIG = {
          apiKey: "AIzaSyCVWUnnXiOvKRqbvngafdZC7DedEY-7vpg",
          authDomain: "lifexpapp-f5578.firebaseapp.com",
          projectId: "lifexpapp-f5578",
          storageBucket: "lifexpapp-f5578.appspot.com",
          messagingSenderId: "194098013746",
          appId: "1:194098013746:web:720ba296ee9e40dee37e2b"
        };
        
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getRemoteConfig, fetchAndActivate, getString } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-remote-config.js";

        let GEMINI_API_KEY = "";
        let playlistGenerationState = { isCancelled: false };

        const loginView = document.getElementById('login-view');
        const mainView = document.getElementById('main-view');
        const mainControls = document.getElementById('main-controls');
        const loginButton = document.getElementById('login-button');
        const generateButton = document.getElementById('generate-button');
        const apiKeyStatus = document.getElementById('api-key-status');
        const songInput = document.getElementById('song-input');
        const userProfile = document.getElementById('user-profile');
        const resultsView = document.getElementById('results-view');
        const playlistLinks = document.getElementById('playlist-links');
        const loadingModal = document.getElementById('loading-modal');
        const loadingText = document.getElementById('loading-text');
        const playlistLengthInput = document.getElementById('playlist-length');
        const numPlaylistsInput = document.getElementById('num-playlists');
        const progressBar = document.getElementById('progress-bar');
        const cancelButton = document.getElementById('cancel-button');
        const themeToggleButton = document.getElementById('theme-toggle'); // NEW

        // --- NEW: Theme Toggle Logic ---
        themeToggleButton.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            let currentTheme = 'light';
            if (document.body.classList.contains('dark-mode')) {
                currentTheme = 'dark';
            }
            localStorage.setItem('theme', currentTheme);
        });
        
        class CancellationError extends Error {
            constructor(message) {
                super(message);
                this.name = "CancellationError";
            }
        }

        async function initializeFirebaseAndGetApiKey() {
            try {
                const app = initializeApp(FIREBASE_CONFIG);
                const remoteConfig = getRemoteConfig(app);
                remoteConfig.settings.minimumFetchIntervalMillis = 0; 
                await fetchAndActivate(remoteConfig);
                GEMINI_API_KEY = getString(remoteConfig, "gemini_api_key");

                if (GEMINI_API_KEY) {
                    console.log("Gemini API Key loaded successfully.");
                    generateButton.disabled = false;
                    apiKeyStatus.textContent = "AI ENGINE: READY";
                    apiKeyStatus.style.color = 'var(--y2k-blue)';
                } else {
                    throw new Error("Gemini API key is empty in Remote Config.");
                }
            } catch (err) {
                console.error("Firebase/Remote Config Error:", err);
                apiKeyStatus.textContent = "ERROR: AI ENGINE OFFLINE";
                apiKeyStatus.style.color = 'var(--danger-red)'; 
                console.error("Error: Could not load the Gemini API Key from Firebase. Please check your configuration and ensure the 'gemini_api_key' parameter is set in Remote Config.");
            }
        }

        window.onload = async () => {
            const args = new URLSearchParams(window.location.search);
            const code = args.get('code');

            if (code) {
                try {
                    await getAccessToken(code);
                    window.history.replaceState({}, document.title, window.location.pathname);
                    await initializeUI();
                } catch (error) {
                    console.error("Error getting access token:", error);
                }
            } else if (localStorage.getItem('spotify_access_token')) {
                await initializeUI();
            }
        };

        loginButton.addEventListener('click', async () => {
            const codeVerifier = generateRandomString(64);
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            localStorage.setItem('spotify_code_verifier', codeVerifier);
            const scope = 'playlist-modify-public playlist-modify-private';
            const authUrl = new URL("https://accounts.spotify.com/authorize");
            const params = {
                response_type: 'code',
                client_id: SPOTIFY_CLIENT_ID,
                scope: scope,
                code_challenge_method: 'S256',
                code_challenge: codeChallenge,
                redirect_uri: REDIRECT_URI,
            };
            authUrl.search = new URLSearchParams(params).toString();
            window.location.href = authUrl.toString();
        });

        async function getAccessToken(code) {
            const codeVerifier = localStorage.getItem('spotify_code_verifier');
            const response = await fetch("https://accounts.spotify.com/api/token", {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({
                    client_id: SPOTIFY_CLIENT_ID,
                    grant_type: 'authorization_code',
                    code: code,
                    redirect_uri: REDIRECT_URI,
                    code_verifier: codeVerifier,
                }),
            });
            if (!response.ok) throw new Error('Failed to fetch access token');
            const data = await response.json();
            localStorage.setItem('spotify_access_token', data.access_token);
            localStorage.setItem('spotify_refresh_token', data.refresh_token);
            localStorage.setItem('spotify_token_expires_at', Date.now() + data.expires_in * 1000);
        }

        async function getValidAccessToken() {
            const expiresAt = localStorage.getItem('spotify_token_expires_at');
            if (Date.now() > expiresAt) {
                console.log("Refreshing Spotify token...");
                const refreshToken = localStorage.getItem('spotify_refresh_token');
                if (!refreshToken) return null;
                const response = await fetch("https://accounts.spotify.com/api/token", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        grant_type: 'refresh_token',
                        refresh_token: refreshToken,
                        client_id: SPOTIFY_CLIENT_ID,
                    }),
                });
                if (!response.ok) {
                    console.error("Failed to refresh token");
                    localStorage.clear();
                    loginView.style.display = 'block';
                    mainView.style.display = 'none';
                    mainControls.style.display = 'none';
                    return null;
                }
                const data = await response.json();
                localStorage.setItem('spotify_access_token', data.access_token);
                if (data.refresh_token) localStorage.setItem('spotify_refresh_token', data.refresh_token);
                localStorage.setItem('spotify_token_expires_at', Date.now() + data.expires_in * 1000);
            }
            return localStorage.getItem('spotify_access_token');
        }
        
        async function initializeUI() {
            const accessToken = await getValidAccessToken();
            if (!accessToken) return;
            try {
                const profile = await fetchWebApi('v1/me', 'GET', accessToken);
                userProfile.innerHTML = `
                    <span>${profile.display_name}</span>
                    <img src="${profile.images[0]?.url || 'https://placehold.co/40x40/C5D4E8/212536?text=S'}" alt="Profile Picture">
                `;
                loginView.style.display = 'none';
                mainView.style.display = 'block';
                mainControls.style.display = 'block';
                await initializeFirebaseAndGetApiKey();
            } catch (error) {
                console.error("Error initializing UI:", error);
                localStorage.clear();
                loginView.style.display = 'block';
                mainView.style.display = 'none';
                mainControls.style.display = 'none';
            }
        }

        function setupDPad(container) {
            container.addEventListener('click', (event) => {
                const button = event.target.closest('.d-pad-button');
                if (!button) return;

                const targetId = button.dataset.target;
                const action = button.dataset.action;
                const input = document.getElementById(targetId);
                
                if (!input) return;

                const min = parseFloat(input.min);
                const max = parseFloat(input.max);
                const step = parseFloat(input.step) || 1;
                let currentValue = parseFloat(input.value);

                if (isNaN(currentValue)) currentValue = action === 'increment' ? min : max;

                if (action === 'increment') {
                    currentValue = Math.min(max, currentValue + step);
                } else if (action === 'decrement') {
                    currentValue = Math.max(min, currentValue - step);
                }

                input.value = currentValue;
            });
        }
        
        function setupInputValidation(input) {
            input.addEventListener('change', (e) => {
                const inputEl = e.target;
                const min = parseFloat(inputEl.min);
                const max = parseFloat(inputEl.max);
                let value = parseFloat(inputEl.value);

                if (isNaN(value)) {
                    value = min; 
                }

                if (value < min) value = min;
                if (value > max) value = max;
                inputEl.value = value;
            });
        }

        document.querySelectorAll('.controls-grid > div').forEach(setupDPad);
        document.querySelectorAll('.d-pad-input').forEach(setupInputValidation);


        cancelButton.addEventListener('click', () => {
            playlistGenerationState.isCancelled = true;
            updateProgress(progressBar.style.width.replace('%',''), "Cancelling...");
            console.log("Cancellation requested by user.");
        });

        generateButton.addEventListener('click', async () => {
            playlistGenerationState.isCancelled = false;
            resultsView.style.display = 'none';
            playlistLinks.innerHTML = '';
            showLoadingModal("Processing your input...");
            updateProgress(0);

            const playlistLength = parseInt(playlistLengthInput.value, 10);
            const numPlaylists = parseInt(numPlaylistsInput.value, 10);

            if (isNaN(playlistLength) || playlistLength < 3 || playlistLength > 150) {
                alert("Please set 'Tracks per Mix' between 3 and 150.");
                hideLoadingModal();
                return;
            }
            if (isNaN(numPlaylists) || numPlaylists < 1 || numPlaylists > 10) {
                alert("Please set 'Number of Mixes' between 1 and 10.");
                hideLoadingModal();
                return;
            }
            if ((playlistLength * numPlaylists) > 150) {
                alert("The total number of songs (Tracks per Mix Ã— Number of Mixes) cannot exceed 150.");
                hideLoadingModal();
                return;
            }
            
            try {
                if (playlistGenerationState.isCancelled) throw new CancellationError("Cancelled before start.");
                
                updateProgress(2, "Authenticating with Spotify...");
                const accessToken = await getValidAccessToken();
                
                updateProgress(5, "Processing your input...");
                const processedInput = await processUserInput(songInput.value, accessToken);
                
                if (processedInput.length === 0) {
                    alert("Please enter at least one song, artist, or vibe.");
                    hideLoadingModal();
                    return;
                }
                
                if (playlistGenerationState.isCancelled) throw new CancellationError("Cancelled before Gemini call.");
                updateProgress(10, "Calling the AI to generate ideas...");

                const geminiResponse = await callGeminiWithRetries(processedInput, numPlaylists, playlistLength);
                
                if (playlistGenerationState.isCancelled) throw new CancellationError("Cancelled after Gemini call.");
                
                const playlistsToCreate = geminiResponse.curated_playlists;

                if (!playlistsToCreate || playlistsToCreate.length === 0) {
                    throw new Error("Gemini didn't return any playlists. Try rephrasing your input.");
                }

                updateProgress(20, "AI ideas received. Preparing to create playlists...");
                const user = await fetchWebApi('v1/me', 'GET', accessToken);
                const userId = user.id;
                const createdPlaylistData = [];
                const totalPlaylists = playlistsToCreate.length;

                const loopProgressStart = 20;
                const loopProgressWeight = 75;

                for (const [index, playlist] of playlistsToCreate.entries()) {
                    if (playlistGenerationState.isCancelled) throw new CancellationError("Cancelled during playlist creation loop.");

                    const playlistBaseProgress = loopProgressStart + (index / totalPlaylists) * loopProgressWeight;
                    const weightForThisPlaylist = loopProgressWeight / totalPlaylists;

                    const finalTrackUris = await fillPlaylistToLength(playlist, playlistLength, accessToken, index, totalPlaylists, playlistBaseProgress, weightForThisPlaylist);

                    if (playlistGenerationState.isCancelled) throw new CancellationError("Cancelled during track finding.");

                    if (finalTrackUris.length > 0) {
                        const createProgress = playlistBaseProgress + (weightForThisPlaylist * 0.95);
                        updateProgress(createProgress, `[${index + 1}/${totalPlaylists}] Creating playlist on Spotify...`);
                        
                        const newPlaylist = await createSpotifyPlaylist(userId, playlist.playlist_title, playlist.playlist_description, accessToken);
                        await addTracksToPlaylist(newPlaylist.id, finalTrackUris, accessToken);
                        createdPlaylistData.push({ name: newPlaylist.name, url: newPlaylist.external_urls.spotify });
                    } else {
                         console.warn(`Skipping playlist "${playlist.playlist_title}" as no valid tracks could be found.`);
                    }

                    const finalPlaylistProgress = loopProgressStart + ((index + 1) / totalPlaylists) * loopProgressWeight;
                    updateProgress(finalPlaylistProgress, `[${index + 1}/${totalPlaylists}] Playlist "${playlist.playlist_title}" created!`);
                }
                updateProgress(100, "All playlists created!");
                displayResults(createdPlaylistData);

            } catch (error) {
                if (error instanceof CancellationError) {
                    console.log(error.message);
                    resultsView.style.display = 'block';
                    playlistLinks.innerHTML = `<p style="text-align:center;">Playlist creation was cancelled.</p>`;
                } else {
                    console.error("Error during playlist generation:", error);
                    alert(`An error occurred: ${error.message}`);
                }
            } finally {
                setTimeout(hideLoadingModal, 1000);
            }
        });

        async function fillPlaylistToLength(playlist, desiredLength, accessToken, playlistIndex, totalPlaylists, baseProgress, progressWeight) {
            let finalUris = new Map();
            let allSuggestedTracks = [...playlist.tracks];
            let searchedTracks = new Set(allSuggestedTracks.map(t => `${t.artist} - ${t.song_title}`.toLowerCase()));
            let notFoundTrackNames = new Set();
            let consecutiveFailedRounds = 0;
            const MAX_CONSECUTIVE_FAILS = 3;

            while (finalUris.size < desiredLength) {
                if (playlistGenerationState.isCancelled) return [];
                const deficit = desiredLength - finalUris.size;
                if (deficit <= 0) break;

                let tracksFoundThisRound = 0;

                const fillPercentage = finalUris.size / desiredLength;
                const currentProgress = baseProgress + (fillPercentage * (progressWeight * 0.95));
                updateProgress(currentProgress, `[${playlistIndex + 1}/${totalPlaylists}] Finding songs for "${playlist.playlist_title}"... (${finalUris.size}/${desiredLength})`);


                if (allSuggestedTracks.length < deficit) {
                    if (playlistGenerationState.isCancelled) return [];
                    console.log(`Pool is low (${allSuggestedTracks.length} tracks). Requesting more from Gemini.`);
                    
                    const foundTrackNames = Array.from(finalUris.values());
                    const newSuggestions = await getSupplementaryTracksFromGemini(playlist, foundTrackNames, Array.from(notFoundTrackNames), deficit, accessToken);
                    
                    if (newSuggestions.length === 0) {
                        console.warn("Gemini provided no new tracks in this attempt.");
                    } else {
                        let addedCount = 0;
                        newSuggestions.forEach(t => {
                            const trackId = `${t.artist} - ${t.song_title}`.toLowerCase();
                            if (!searchedTracks.has(trackId)) {
                                searchedTracks.add(trackId);
                                allSuggestedTracks.push(t);
                                addedCount++;
                            }
                        });
                        console.log(`Added ${addedCount} new unique suggestions to the pool.`);
                    }
                }

                if (allSuggestedTracks.length === 0) {
                    consecutiveFailedRounds++;
                    if (consecutiveFailedRounds >= MAX_CONSECUTIVE_FAILS) {
                        console.error(`Stopping playlist fill for "${playlist.playlist_title}" after ${MAX_CONSECUTIVE_FAILS} consecutive rounds with no new tracks found.`);
                        alert(`Warning: Could not find enough songs for playlist "${playlist.playlist_title}". It may be shorter than requested.`);
                        break; 
                    }
                    continue;
                }

                const tracksToSearch = allSuggestedTracks.splice(0, Math.max(deficit, 20));
                
                const { found, notFound } = await findTrackUris(tracksToSearch, accessToken);
                
                found.forEach(track => {
                    if (finalUris.size < desiredLength && !finalUris.has(track.uri)) {
                        finalUris.set(track.uri, track.name);
                        tracksFoundThisRound++;
                    }
                });
                notFound.forEach(trackName => notFoundTrackNames.add(trackName));

                if (tracksFoundThisRound === 0) {
                    consecutiveFailedRounds++;
                } else {
                    consecutiveFailedRounds = 0;
                }

                if (consecutiveFailedRounds >= MAX_CONSECUTIVE_FAILS) {
                    console.error(`Stopping playlist fill for "${playlist.playlist_title}" after ${MAX_CONSECUTIVE_FAILS} consecutive rounds with no new tracks found.`);
                    alert(`Warning: Could not find enough songs for playlist "${playlist.playlist_title}". It may be shorter than requested.`);
                    break;
                }
            }

            if (finalUris.size < desiredLength) {
                console.warn(`Playlist "${playlist.playlist_title}" is incomplete. Found ${finalUris.size}/${desiredLength} songs.`);
            } else {
                console.log(`Successfully filled playlist "${playlist.playlist_title}" with ${finalUris.size} songs.`);
            }

            return Array.from(finalUris.keys());
        }

        async function callGeminiWithRetries(userInput, numPlaylists, songsPerPlaylist, maxRetries = 3) {
            let lastError = null;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                if (playlistGenerationState.isCancelled) throw new CancellationError("Cancelled during Gemini retry loop.");
                try {
                    if (attempt > 1) {
                        updateProgress(12, `AI response was unclear. Retrying... (Attempt ${attempt}/${maxRetries})`);
                    }
                    
                    const response = await callGeminiApi(userInput, numPlaylists, songsPerPlaylist);

                    if (response && Array.isArray(response.curated_playlists)) {
                        console.log(`Successfully received and validated Gemini response on attempt ${attempt}.`);
                        return response;
                    } else {
                        throw new Error("Invalid response structure received from Gemini.");
                    }

                } catch (error) {
                    console.warn(`Attempt ${attempt} failed:`, error.message);
                    lastError = error;
                    if (attempt < maxRetries) {
                        const delay = 1000 * attempt;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }
            console.error("All Gemini API attempts failed.");
            throw lastError;
        }

        async function processUserInput(rawInput, accessToken) {
            const lines = rawInput.trim().split('\n').filter(line => line.trim().length > 0);
            const processedLines = [];
            const trackIds = [];

            const spotifyTrackRegex = /open\.spotify\.com\/track\/([a-zA-Z0-9]+)/;

            for (const line of lines) {
                const match = line.match(spotifyTrackRegex);
                if (match && match[1]) {
                    trackIds.push(match[1]);
                } else {
                    processedLines.push(line.replace(/^>\s*/, ''));
                }
            }

            if (trackIds.length > 0) {
                try {
                    const tracksData = await fetchWebApi(`v1/tracks?ids=${trackIds.join(',')}`, 'GET', accessToken);
                    if (tracksData && tracksData.tracks) {
                        const trackStrings = tracksData.tracks.map(track => 
                            track ? `${track.artists.map(a => a.name).join(', ')} - ${track.name}` : ''
                        ).filter(Boolean);
                        processedLines.unshift(...trackStrings);
                    }
                } catch (error) {
                    console.error("Error fetching Spotify track details:", error);
                }
            }
            return processedLines;
        }
        
        async function callGeminiApi(userInput, numPlaylists, songsPerPlaylist) {
            if (!GEMINI_API_KEY) throw new Error("Gemini API Key is not loaded.");
            
            const prompt = `
# Role & Goal
You are DJ-ViBES, an expert music curator. Your goal is to interpret a user's input, which can be a mix of songs, artists, Spotify links, genres, or abstract "vibes", and then craft multiple, curated playlists.

# Input Analysis
The user has provided the following input. It could be anything from specific tracks to moods. Interpret the collective essence of this list.
User Input:
${userInput.join('\n')}

# Core Instructions
1.  Analyze the user's input to understand the desired musical atmosphere, genres, and themes.
2.  Create exactly ${numPlaylists} distinct playlists that capture different facets of the user's request.
3.  For EACH playlist, generate a list of exactly ${songsPerPlaylist} songs.
4.  The generated tracks should be relevant but should NOT include any songs that were explicitly in the user's input list, unless the input specifically asks for it, e.g.: "the best of â€¦".
5.  Do not repeat song suggestions across the different playlists you create.
6.  Give each playlist a creative, descriptive title and a brief description.
7.  Arrange the tracks in a logical sequence that flows well.

# Rules & Constraints
- Your ENTIRE response MUST be a single, valid JSON object.
- Do not include any text, notes, or apologies outside of the JSON structure.
- Do not use markdown backticks like \`\`\`json in your response.
- Ensure song titles and artist names are as accurate as possible to maximize findability on Spotify.

# JSON Output Structure
{"curated_playlists":[{"playlist_title":"string","playlist_description":"string","tracks":[{"song_title":"string","artist":"string"}]}]}
`;
            const api_url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            
            let responseText = "";
            try {
                const response = await fetch(api_url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { responseMimeType: "application/json" }
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("Gemini API Error Response:", errorText);
                    throw new Error(`Failed to get a valid response from the Gemini API. Status: ${response.status}`);
                }

                const data = await response.json();

                if (!data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) {
                    console.error("Invalid response structure from initial Gemini call:", data);
                    throw new Error("Malformed response structure from Gemini.");
                }

                responseText = data.candidates[0].content.parts[0].text;
                return JSON.parse(responseText);
            } catch (e) {
                console.error("Failed to parse initial Gemini JSON response:", e);
                if (responseText) {
                    console.error("Raw text from Gemini that failed to parse:", responseText);
                }
                throw new Error("Gemini returned a malformed response. Please try again.");
            }
        }

        async function getSupplementaryTracksFromGemini(playlist, foundTrackNames, notFoundTracks, deficit, accessToken) {
            if (!GEMINI_API_KEY) {
                console.error("Attempted to call supplementary Gemini without API Key.");
                return [];
            }
            if (playlistGenerationState.isCancelled) return [];
            
            const tracksToRequest = deficit + 5;

            const prompt = `
# Role & Goal
You are an assistant to DJ-ViBES. Your task is to find replacement songs for a playlist because some of the previous suggestions could not be found on Spotify.

# Playlist Context
- **Playlist Title:** "${playlist.playlist_title}"
- **Playlist Description:** "${playlist.playlist_description}"
- **Songs already found and added:**
${foundTrackNames.length > 0 ? foundTrackNames.map(t => `- ${t}`).join('\n') : "None yet."}
- **Songs we FAILED to find on Spotify (do not suggest these again):**
${notFoundTracks.length > 0 ? notFoundTracks.map(t => `- ${t}`).join('\n') : "None."}

# Core Instructions
1.  Analyze the playlist context and the lists of found/failed songs to understand the vibe.
2.  Generate a list of exactly ${tracksToRequest} NEW song suggestions that fit this vibe.
3.  **Crucially, DO NOT suggest any songs from the "found" or "failed" lists above.**
4.  Provide only real songs with accurate artist and title information.

# Rules & Constraints
- Your ENTIRE response MUST be a single, valid JSON object.
- Do not include any text, notes, or apologies outside of the JSON structure.
- Do not use markdown backticks like \`\`\`json in your response.

# JSON Output Structure
{"tracks":[{"song_title":"string","artist":"string"}]}
`;
            const api_url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            
            let responseText = "";
            try {
                const response = await fetch(api_url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { responseMimeType: "application/json" }
                    })
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    console.error("Supplementary Gemini API call failed with status:", response.status, "Body:", errorBody);
                    throw new Error(`Supplementary Gemini API call failed with status ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) {
                    console.error("Invalid response structure from supplementary Gemini call:", data);
                    throw new Error("Malformed response structure from Gemini.");
                }

                responseText = data.candidates[0].content.parts[0].text;
                const parsedJson = JSON.parse(responseText);
                return parsedJson.tracks || [];

            } catch(e) {
                console.error("Failed to get or parse supplementary tracks from Gemini:", e);
                if (responseText) {
                    console.error("Raw text from Gemini that failed to parse:", responseText);
                }
                return [];
            }
        }

        async function findTrackUris(tracks, accessToken) {
            let found = [];
            let notFound = [];

            for (const track of tracks) {
                if (playlistGenerationState.isCancelled) return { found: [], notFound: [] };
                const query = `track:"${track.song_title}" artist:"${track.artist}"`;
                const trackIdentifier = `${track.artist} - ${track.song_title}`;
                try {
                    await new Promise(resolve => setTimeout(resolve, 50)); 
                    const searchResults = await fetchWebApi(`v1/search?q=${encodeURIComponent(query)}&type=track&limit=1`, 'GET', accessToken);
                    if (searchResults.tracks.items.length > 0) {
                        const foundTrack = searchResults.tracks.items[0];
                        found.push({
                            uri: foundTrack.uri,
                            name: `${foundTrack.artists.map(a => a.name).join(', ')} - ${foundTrack.name}`
                        });
                    } else {
                        notFound.push(trackIdentifier);
                    }
                } catch (error) {
                    console.error(`Error searching for "${query}":`, error);
                    notFound.push(trackIdentifier);
                }
            }
            return { found, notFound };
        }
        
        async function createSpotifyPlaylist(userId, name, description, accessToken) {
            return await fetchWebApi(`v1/users/${userId}/playlists`, 'POST', accessToken, {
                name: name,
                description: description,
                public: false
            });
        }

        async function addTracksToPlaylist(playlistId, trackUris, accessToken) {
            for (let i = 0; i < trackUris.length; i += 100) {
                if (playlistGenerationState.isCancelled) return;
                const chunk = trackUris.slice(i, i + 100);
                await fetchWebApi(`v1/playlists/${playlistId}/tracks`, 'POST', accessToken, {
                    uris: chunk
                });
            }
        }

        function displayResults(createdPlaylists) {
            if (createdPlaylists.length === 0 && !playlistGenerationState.isCancelled) {
                playlistLinks.innerHTML = `<p style="text-align:center;">Could not create any playlists. Try a different input.</p>`;
            } else if (createdPlaylists.length > 0) {
                playlistLinks.innerHTML = createdPlaylists.map(p => `
                    <a href="${p.url}" target="_blank">
                        <p class="playlist-name">${p.name}</p>
                        <p class="playlist-url">Open on Spotify â†’</p>
                    </a>
                `).join('');
            }
            resultsView.style.display = 'block';
        }

        async function fetchWebApi(endpoint, method, token, body) {
            const headers = { 'Authorization': `Bearer ${token}` };
            if (body) {
                headers['Content-Type'] = 'application/json';
            }

            const res = await fetch(`https://api.spotify.com/${endpoint}`, {
                headers,
                method,
                body: body ? JSON.stringify(body) : undefined,
            });

            if (!res.ok) {
                let errorMessage = `Request failed with status ${res.status}`;
                try {
                    const error = await res.json();
                    if (error.error && error.error.message) {
                        errorMessage = error.error.message;
                    }
                } catch (e) { }
                throw new Error(errorMessage);
            }

            if (res.status === 204) return null;
            return await res.json();
        }

        function generateRandomString(length) {
            let text = '';
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }

        async function generateCodeChallenge(plain) {
            const encoder = new TextEncoder();
            const data = encoder.encode(plain);
            const digest = await window.crypto.subtle.digest('SHA-256', data);
            return btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        function showLoadingModal(text) {
            loadingText.textContent = text;
            loadingModal.style.display = 'flex';
        }

        function hideLoadingModal() {
            loadingModal.style.display = 'none';
        }

        function updateProgress(percentage, text) {
            progressBar.style.width = `${percentage}%`;
            if (text) {
                loadingText.textContent = text;
            }
        }
    </script>
</body>
</html>
